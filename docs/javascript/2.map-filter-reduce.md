# 2. map, filter & reduce

## Introduction

JavaScript arrays provide `map`, `filter`, and `reduce` methods for transforming and processing data.  
Each method uses a **callback function** and can optionally use a custom `this` context (except `reduce`).  
Understanding their callback signatures, `this` binding, and return values is essential.

---

## 1. `Array.map()`

- **Purpose:** Transform each element and return a new array.
- **Does not mutate** the original array.
- **Callback signature:** `(currentValue, index, array)`
- **`this` binding:** Can be set with a second argument.

### Example 1: Arrow Function

```javascript
const nums = [1, 2, 3, 4];
const multiplyThree = nums.map((num, i, arr) => num * 3);
console.log(multiplyThree); // [3, 6, 9, 12]
```

### Example 2: Normal Function

```javascript
const multiplyThree = nums.map(function(num, i, arr) {
  return num * 3;
});
console.log(multiplyThree); // [3, 6, 9, 12]
```

### Example 3: Using `this` Binding

```javascript
const multiplier = {
  factor: 5,
  multiply(num) {
    // Here, 'this' refers to the 'multiplier' object
    return num * this.factor;
  }
};

const nums = [1, 2, 3];

// In the callback, 'this' will be set to the 'multiplier' object because we pass it as the second argument to map.
// So inside the callback, 'this' is NOT the array, but the 'multiplier' object.
const result = nums.map(function(num) {
  // 'this' here === multiplier
  return this.multiply(num);
}, multiplier);

console.log(result); // [5, 10, 15]
```
> **Note:**  
> - If you use an arrow function as the callback, `this` will NOT be set by the second argument (arrow functions don't have their own `this`).
> - If you use a regular function, `this` inside the callback will be whatever you pass as the second argument.

---

## 2. `Array.filter()`

- **Purpose:** Filter elements based on a condition and return a new array.
- **Does not mutate** the original array.
- **Callback signature:** `(currentValue, index, array)`
- **`this` binding:** Can be set with a second argument.

### Example 1: Arrow Function

```javascript
const nums = [1, 2, 3, 4];
const moreThanTwo = nums.filter((num, i, arr) => num > 2);
console.log(moreThanTwo); // [3, 4]
```

### Example 2: Normal Function

```javascript
const moreThanTwo = nums.filter(function(num, i, arr) {
  return num > 2;
});
console.log(moreThanTwo); // [3, 4]
```

### Example 3: Using `this` Binding

```javascript
const threshold = {
  min: 3,
  isGreater(num) {
    // Here, 'this' refers to the 'threshold' object
    return num > this.min;
  }
};

const nums = [1, 2, 3, 4];

// In the callback, 'this' will be set to the 'threshold' object because we pass it as the second argument to filter.
// So inside the callback, 'this' is NOT the array, but the 'threshold' object.
const filtered = nums.filter(function(num) {
  // 'this' here === threshold
  return this.isGreater(num);
}, threshold);

console.log(filtered); // [4]
```
> **Note:**  
> - Arrow functions ignore the `thisArg` and use the surrounding `this`.
> - Regular functions use the `thisArg` as `this` inside the callback.

---

## 3. `Array.reduce()`

- **Purpose:** Reduce the array to a single value (sum, product, object, etc.).
- **Does not mutate** the original array.
- **Callback signature:** `(accumulator, currentValue, index, array)`
- **Initial value:** If not provided, the first element is used as the initial accumulator.
- **`this` binding:** Cannot be set with a second argument (the second argument is always the initial value).

### Example 1: Arrow Function

```javascript
const nums = [1, 2, 3, 4];
const sum = nums.reduce((acc, curr) => acc + curr, 0);
console.log(sum); // 10
```

### Example 2: Normal Function

```javascript
const sum = nums.reduce(function(acc, curr, i, arr) {
  return acc + curr;
}, 0);
console.log(sum); // 10
```

---

## 4. Polyfill Implementations

### Map Polyfill

#### Without `cb.call` (no custom `this`):

```javascript
Array.prototype.myMap = function(cb) {
  let temp = [];
  for (let i = 0; i < this.length; i++) {
    // Here, 'this' inside cb is undefined or the global object (not set)
    temp.push(cb(this[i], i, this));
  }
  return temp;
};
```

#### With `cb.call` (supports custom `this`):

```javascript
Array.prototype.myMap = function(cb, thisArg) {
  let temp = [];
  for (let i = 0; i < this.length; i++) {
    // Here, 'this' inside cb will be set to thisArg
    temp.push(cb.call(thisArg, this[i], i, this));
  }
  return temp;
};
```

---

### Filter Polyfill

#### Without `cb.call` (no custom `this`):

```javascript
Array.prototype.myFilter = function(cb) {
  let temp = [];
  for (let i = 0; i < this.length; i++) {
    // 'this' inside cb is not set
    if (cb(this[i], i, this)) temp.push(this[i]);
  }
  return temp;
};
```

#### With `cb.call` (supports custom `this`):

```javascript
Array.prototype.myFilter = function(cb, thisArg) {
  let temp = [];
  for (let i = 0; i < this.length; i++) {
    // 'this' inside cb will be set to thisArg
    if (cb.call(thisArg, this[i], i, this)) temp.push(this[i]);
  }
  return temp;
};
```

---

### Reduce Polyfill

#### Standard (no custom `this`):

```javascript
Array.prototype.myReduce = function(cb, initialValue) {
  let accumulator = initialValue;
  let startIndex = 0;

  if (accumulator === undefined) {
    accumulator = this[0];
    startIndex = 1;
  }

  for (let i = startIndex; i < this.length; i++) {
    accumulator = cb(accumulator, this[i], i, this);
  }
  return accumulator;
};
```
> **Note:**  
> - `reduce` does **not** support a custom `this` for the callback; the second argument is always the initial value.

---

## 5. map vs forEach

- `map` returns a new array with the results of the callback.
- `forEach` executes a function for each element but returns `undefined`.
- Both accept a second argument for `this` binding (but only works with regular functions).

**Example:**
```javascript
const arr = [1, 2, 3];
arr.map(function(x) { console.log(this, x); }, { label: "mapThis" });
// 'this' inside callback is { label: "mapThis" }

arr.forEach(function(x) { console.log(this, x); }, { label: "forEachThis" });
// 'this' inside callback is { label: "forEachThis" }
```

---

## 6. Practice Questions

Given:
```javascript
let students = [
  { name: "Piyush", rollNumber: 31, marks: 80 },
  { name: "Jenny", rollNumber: 15, marks: 69 },
  { name: "Kaushal", rollNumber: 16, marks: 35 },
  { name: "Dilpreet", rollNumber: 7, marks: 55 },
];
```

### Q1: Return only the names of students in capital letters

```javascript
const names = students.map((stu) => stu.name.toUpperCase());
console.log(names); // ["PIYUSH", "JENNY", "KAUSHAL", "DILPREET"]
```

---

### Q2: Get details of students who scored more than 60 marks

```javascript
const highScorers = students.filter((stu) => stu.marks > 60);
console.log(highScorers);
```

---

### Q3: Get details of students who scored more than 60 marks and have rollNumber greater than 15

```javascript
const filtered = students.filter((stu) => stu.marks > 60 && stu.rollNumber > 15);
console.log(filtered);
```

---

### Q4: Sum total of the marks of the students

```javascript
const totalMarks = students.reduce((acc, stu) => acc + stu.marks, 0);
console.log(totalMarks); // 239
```

---

### Q5: Get only the names of the students who scored more than 60 marks

```javascript
const names = students
  .filter((stu) => stu.marks > 60)
  .map((stu) => stu.name);
console.log(names); // ["Piyush", "Jenny"]
```

---

### Q6: Print the total marks of the students with marks greater than 60 after 20 marks have been added to those who scored less than 60

```javascript
const totalMarks = students
  .map((stu) => {
    // Don't mutate original object, return a new one
    if (stu.marks < 60) {
      return { ...stu, marks: stu.marks + 20 };
    }
    return stu;
  })
  .filter((stu) => stu.marks > 60)
  .reduce((acc, stu) => acc + stu.marks, 0);

console.log(totalMarks);
```

---

## Summary Table

| Method   | Returns New Array | Mutates Original | Callback `this` | Use Case                |
|----------|------------------|------------------|-----------------|-------------------------|
| map      | Yes              | No               | Yes             | Transform each element  |
| filter   | Yes              | No               | Yes             | Filter elements         |
| reduce   | No (single value)| No               | No              | Aggregate to one value  |
| forEach  | No               | No               | Yes             | Side effects/iteration  |

---