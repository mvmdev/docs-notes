"use strict";(self.webpackChunkmy_doc_site=self.webpackChunkmy_doc_site||[]).push([[251],{3546:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>a});var i=o(9729);const s={},l=i.createContext(s);function c(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(l.Provider,{value:n},e.children)}},7568:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"javascript/var-let-const","title":"1.var-let-const","description":"Scope in JavaScript","source":"@site/docs/javascript/1.var-let-const.md","sourceDirName":"javascript","slug":"/javascript/var-let-const","permalink":"/docs-notes/docs/javascript/var-let-const","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/javascript/1.var-let-const.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Javascript","permalink":"/docs-notes/docs/category/javascript"},"next":{"title":"2. map, filter & reduce","permalink":"/docs-notes/docs/javascript/map-filter-reduce"}}');var s=o(5813),l=o(3546);const c={sidebar_position:1},a="1.var-let-const",r={},t=[{value:"Scope in JavaScript",id:"scope-in-javascript",level:2},{value:"<code>var</code>",id:"var",level:3},{value:"<code>let</code> and <code>const</code>",id:"let-and-const",level:3},{value:"Types of Scope in JavaScript",id:"types-of-scope-in-javascript",level:2},{value:"Example of Scope",id:"example-of-scope",level:3},{value:"Redeclaration",id:"redeclaration",level:2},{value:"Attachment to the Global Object",id:"attachment-to-the-global-object",level:2},{value:"<code>let</code> vs. <code>var</code> in Loops",id:"let-vs-var-in-loops",level:2},{value:"Question 1: Variable Shadowing",id:"question-1-variable-shadowing",level:2},{value:"Question 2: Illegal Shadowing",id:"question-2-illegal-shadowing",level:2},{value:"Question 3: Hoisting",id:"question-3-hoisting",level:2},{value:"Question 4: Temporal Dead Zone (TDZ)",id:"question-4-temporal-dead-zone-tdz",level:2}];function d(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"1var-let-const",children:"1.var-let-const"})}),"\n",(0,s.jsx)(n.h2,{id:"scope-in-javascript",children:"Scope in JavaScript"}),"\n",(0,s.jsxs)(n.p,{children:["In JavaScript, ",(0,s.jsx)(n.code,{children:"var"}),", ",(0,s.jsx)(n.code,{children:"let"}),", and ",(0,s.jsx)(n.code,{children:"const"})," have different scoping behaviors."]}),"\n",(0,s.jsx)(n.h3,{id:"var",children:(0,s.jsx)(n.code,{children:"var"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Variables declared with ",(0,s.jsx)(n.code,{children:"var"})," are ",(0,s.jsx)(n.strong,{children:"function-scoped"})," or ",(0,s.jsx)(n.strong,{children:"globally-scoped"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"If declared outside any function, it becomes a global variable."}),"\n",(0,s.jsx)(n.li,{children:"If declared inside a function, it is scoped to that function."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"var"})," does ",(0,s.jsx)(n.strong,{children:"not"})," respect block scope (e.g., within ",(0,s.jsx)(n.code,{children:"if"})," statements or ",(0,s.jsx)(n.code,{children:"for"})," loops)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'var globalVar = "I am global";\nfunction myFunction() {\n  var functionVar = "I am in function scope";\n  if (true) {\n    var blockVar = "I am in block scope"; // Still accessible outside the if block\n    console.log(blockVar); // Accessible here\n  }\n  console.log(functionVar); // Accessible here\n  console.log(blockVar);    // Accessible here\n}\nmyFunction();\nconsole.log(globalVar);      // Accessible here\nconsole.log(functionVar);    // Error: functionVar is not defined\nconsole.log(blockVar);       // Error: blockVar is not defined\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"let-and-const",children:[(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Variables declared with ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})," are ",(0,s.jsx)(n.strong,{children:"block-scoped"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Their scope is limited to the nearest enclosing block (defined by ",(0,s.jsx)(n.code,{children:"{}"}),"), such as within ",(0,s.jsx)(n.code,{children:"if"})," statements, loops, or function bodies."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function anotherFunction() {\n  let functionScopedVar = "I am in function scope";\n  if (true) {\n    let blockScopedVar = "I am in block scope"; // Different variable\n    console.log(blockScopedVar); // Accessible here\n  }\n  console.log(functionScopedVar); // Accessible here\n  // console.log(blockScopedVar); // Error: blockScopedVar is not defined outside the if block\n}\nanotherFunction();\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})," can also be globally scoped if declared at the top level of a script."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let globalLetVar = "I am a global let variable";\nconst globalConstVar = "I am a global const variable";\n// These variables can be accessed anywhere in the script.\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Summary:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"var"})," can be globally scoped if declared outside any function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})," can also be globally scoped if declared outside any block or function, but their main feature is block scoping, which provides more localized control over variable accessibility."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"types-of-scope-in-javascript",children:"Types of Scope in JavaScript"}),"\n",(0,s.jsx)(n.p,{children:"JavaScript has three types of scope:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Global Scope"}),":",(0,s.jsx)(n.br,{}),"\n","Variables declared outside any function or block are in the global scope and can be accessed from anywhere in the code."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Function Scope"}),":",(0,s.jsx)(n.br,{}),"\n","Variables declared within a function are in the function scope and can only be accessed within that function."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Block Scope"}),":",(0,s.jsx)(n.br,{}),"\n","Variables declared with ",(0,s.jsx)(n.code,{children:"let"})," or ",(0,s.jsx)(n.code,{children:"const"})," within a block (e.g., inside an ",(0,s.jsx)(n.code,{children:"if"})," statement or loop) are in the block scope and can only be accessed within that block."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"example-of-scope",children:"Example of Scope"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'var globalVar = "I am global";\nfunction myFunction() {\n  var functionVar = "I am in function scope";\n  if (true) {\n    let blockVar = "I am in block scope";\n    console.log(blockVar); // Accessible here\n  }\n  console.log(functionVar); // Accessible here\n  // console.log(blockVar); // Error: blockVar is not defined\n}\n// myFunction();\n// console.log(globalVar);      // Accessible here\n// console.log(functionVar);    // Error: functionVar is not defined\n// console.log(blockVar);       // Error: blockVar is not defined\n'})}),"\n",(0,s.jsx)(n.h2,{id:"redeclaration",children:"Redeclaration"}),"\n",(0,s.jsx)(n.p,{children:"Another key difference lies in how these keywords handle redeclaration of variables within the same scope."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"var"}),": Allows redeclaration without any error."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"}),": Do not allow redeclaration within the same scope, throwing a ",(0,s.jsx)(n.code,{children:"SyntaxError"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This behavior of ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})," helps prevent accidental redeclarations and makes the code more robust."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Example with ",(0,s.jsx)(n.code,{children:"var"}),":"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"var x = 10;\nvar x = 20; // No error\nconsole.log(x); // 20\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Example with ",(0,s.jsx)(n.code,{children:"let"}),":"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let y = 10;\n// let y = 20; // Throws SyntaxError: Identifier 'y' has already been declared.\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"attachment-to-the-global-object",children:"Attachment to the Global Object"}),"\n",(0,s.jsxs)(n.p,{children:["In the global scope, variables declared with ",(0,s.jsx)(n.code,{children:"var"})," become properties of the global object (",(0,s.jsx)(n.code,{children:"window"})," in browsers). ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})," declarations at the top level do not attach to the global object."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example (in a browser):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'var globalVar = "I am on window";\nlet globalLet = "I am not on window";\nconst globalConst = "Me neither";\n\nconsole.log(window.globalVar);   // "I am on window"\nconsole.log(window.globalLet);   // undefined\nconsole.log(window.globalConst); // undefined\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"let-vs-var-in-loops",children:[(0,s.jsx)(n.code,{children:"let"})," vs. ",(0,s.jsx)(n.code,{children:"var"})," in Loops"]}),"\n",(0,s.jsxs)(n.p,{children:["The block-scoping nature of ",(0,s.jsx)(n.code,{children:"let"})," is particularly useful in loops. A classic JavaScript interview question involves ",(0,s.jsx)(n.code,{children:"setTimeout"})," inside a ",(0,s.jsx)(n.code,{children:"for"})," loop."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Example with ",(0,s.jsx)(n.code,{children:"var"}),":"]}),"\nWhen using ",(0,s.jsx)(n.code,{children:"var"}),", the same variable ",(0,s.jsx)(n.code,{children:"i"})," is used for every iteration of the loop. By the time the ",(0,s.jsx)(n.code,{children:"setTimeout"})," callbacks execute, the loop has already finished, and ",(0,s.jsx)(n.code,{children:"i"})," is at its final value (5 in this case)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"for (var i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 1000);\n}\n// Output: 5, 5, 5, 5, 5\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Example with ",(0,s.jsx)(n.code,{children:"let"}),":"]}),"\nWhen using ",(0,s.jsx)(n.code,{children:"let"}),", a new binding for ",(0,s.jsx)(n.code,{children:"i"})," is created for each iteration of the loop. Each ",(0,s.jsx)(n.code,{children:"setTimeout"})," callback captures a different ",(0,s.jsx)(n.code,{children:"i"})," with the value it had for that specific iteration."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"for (let i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 1000);\n}\n// Output: 0, 1, 2, 3, 4\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"question-1-variable-shadowing",children:"Question 1: Variable Shadowing"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Variable Shadowing:"}),(0,s.jsx)(n.br,{}),"\n","In JavaScript, variable shadowing occurs when a variable with the same name as a variable in a higher scope is declared in a lower scope.",(0,s.jsx)(n.br,{}),"\n",'It\'s a common practice but can lead to confusion if not used carefully because the inner variable will "shadow" the outer variable.',(0,s.jsx)(n.br,{}),"\n","In the example below, ",(0,s.jsx)(n.code,{children:"let a"})," inside the ",(0,s.jsx)(n.code,{children:"if"})," block shadows the outer ",(0,s.jsx)(n.code,{children:"let a"}),", and they are two separate variables despite having the same name."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function test() {\n  let a = "Hello";\n\n  if (true) {\n    let a = "Goodbye"; // This \'a\' is a new variable that "shadows" the outer \'a\'.\n    console.log(a);\n  }\n\n  console.log(a);\n}\n\ntest();\n// Expected output:\n// Goodbye\n// Hello\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"question-2-illegal-shadowing",children:"Question 2: Illegal Shadowing"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Illegal Shadowing:"}),(0,s.jsx)(n.br,{}),"\n","This occurs when trying to shadow a variable using ",(0,s.jsx)(n.code,{children:"var"})," within the same scope where that variable is already defined using ",(0,s.jsx)(n.code,{children:"let"})," or ",(0,s.jsx)(n.code,{children:"const"}),".",(0,s.jsx)(n.br,{}),"\n","In the example below, ",(0,s.jsx)(n.code,{children:'var b = "Bye";'})," is illegal shadowing because ",(0,s.jsx)(n.code,{children:"b"})," is already declared using ",(0,s.jsx)(n.code,{children:"let"})," in the same scope."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function func() {\n  var a = "Hello";\n  let b = "Namaste";\n\n  if (true) {\n    let a = "Hi"; // Legal Shadowing\n    var b = "Bye"; // Illegal Shadowing\n    console.log(a); // It will print \'Hi\'\n    console.log(b); // It will print error\n  }\n}\ntest();\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"question-3-hoisting",children:"Question 3: Hoisting"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Hoisting:"}),(0,s.jsx)(n.br,{}),"\n","In JavaScript, hoisting is a behavior where variable and function declarations are moved to the top of their containing scope during the compilation phase.",(0,s.jsx)(n.br,{}),"\n","However, only the declarations are hoisted, not the initializations or assignments.",(0,s.jsx)(n.br,{}),"\n","In the example below, ",(0,s.jsx)(n.code,{children:"console.log(a);"})," will result in ",(0,s.jsx)(n.code,{children:"undefined"})," because the variable ",(0,s.jsx)(n.code,{children:"a"})," is hoisted to the top but not initialized until later in the code (",(0,s.jsx)(n.code,{children:"var a = 10;"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"console.log(a);\n\nvar a = 10;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"question-4-temporal-dead-zone-tdz",children:"Question 4: Temporal Dead Zone (TDZ)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Temporal Dead Zone (TDZ):"}),(0,s.jsx)(n.br,{}),"\n","TDZ is a specific behavior related to variables declared using ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"}),".",(0,s.jsx)(n.br,{}),"\n","It refers to the period between the start of the block scope and the actual declaration of the variable.",(0,s.jsx)(n.br,{}),"\n","During the TDZ, accessing the variable will result in a ",(0,s.jsx)(n.code,{children:"ReferenceError"}),".",(0,s.jsx)(n.br,{}),"\n","In the example below, trying to log ",(0,s.jsx)(n.code,{children:"a"}),", ",(0,s.jsx)(n.code,{children:"b"}),", and ",(0,s.jsx)(n.code,{children:"c"})," before their respective declarations will result in ",(0,s.jsx)(n.code,{children:"ReferenceError"})," for ",(0,s.jsx)(n.code,{children:"b"})," and ",(0,s.jsx)(n.code,{children:"c"})," because the ",(0,s.jsx)(n.code,{children:"let"})," and ",(0,s.jsx)(n.code,{children:"const"})," variables are in the TDZ until they are declared (it will work fine for ",(0,s.jsx)(n.code,{children:"var"})," alone)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"console.log(a, b, c);\n\nconst c = 30;\nlet b = 20;\nvar a = 10;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);